;; a list is of the form (cons a (cons b (cons ... (cons nil)...)))

;; list : make a list out of a (possibly unevaluated) list quote
(letrec ((list (lambda (q)
		 (if (car q)
		     (cons (eval (car q)) (list (cdr q)))
		     '()))))
  (current-env))

;; list-eq : determine if two lists are equal
(letrec ((list-eq (lambda (l1 l2)
    (if (car l1) 
        (if (car l2)
            (if (= (car l1) (car l2))
                (list-eq (cdr l1) (cdr l2))
                nil)
            nil)
        (if (car l2)
            nil
            t)))))
    (current-env))

;; snoc : appends to the right-hand side of a list (opposite of cons)
(letrec 
    ((snoc-iter (lambda (old-list new-list) 
        (if (car old-list)
            (snoc-iter (cdr old-list) (cons (car old-list) new-list))
            new-list)))
    (snoc (lambda (x lst) (snoc-iter (snoc-iter lst '()) (cons x nil))))) 
    (current-env))

;; length : determines the length of a list 
(letrec 
    ((length-iter (lambda (lst cntr)
        (if (car lst)
            (length-iter (cdr lst) (+ 1 cntr))
            cntr)))
    (length (lambda (lst) (length-iter lst 0))))
    (current-env))

;; apply : a preliminary version of apply
(letrec 
    ((apply (lambda (f list)
        (if (car list)
            (if (eq nil (cdr list))
                (f (car list))
                (apply (f (car list)) (cdr list)))))))
    (current-env))

;; map : a list map function 
;; TODO : map that can take multiple lists
(letrec ((map (lambda (f list)
                    (if (eq list nil)
                        nil
                        (cons (f (car list))
                              (map f (cdr list)))))))
      (current-env))


;; fold : a fold function over lists 
(letrec 
    ((fold (lambda (lst op accum)
        (if (car lst)
            (fold (cdr lst) op (op (car lst) accum))
            accum))))
    (current-env))