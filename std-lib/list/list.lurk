;; !(:load "../bool/bool.lurk")

;; a list is of the form (cons a (cons b (cons ... (cons nil)...)))

;; snoc : appends to the right-hand side of a list (opposite of cons)
(letrec 
    ((snoc-iter (lambda (old-list new-list) 
        (if (car old-list)
            (snoc-iter (cdr old-list) (cons (car old-list) new-list))
            new-list)))
    (snoc (lambda (x lst) (snoc-iter (snoc-iter lst '()) (cons x nil))))) 
    (current-env))

;; reverse : reverses the order of a list 
(letrec 
    ((reverse-iter (lambda (list1 list2) 
        (if (car list1)
            (reverse-iter (cdr list1) (cons (car list1) list2))
            list2))) 
    (reverse (lambda (list) (reverse-iter list nil)))) 
    (current-env))

;; cxxxr combinations (up to 3) 
(let ((cadr (lambda (list) (car (cdr list))))
      (caar (lambda (list) (car (car list))))
      (cdar (lambda (list) (cdr (car list))))
      (cddr (lambda (list) (cdr (cdr list))))
      (cdddr (lambda (list) (car (cdr (cdr list)))))
      (cddar (lambda (list) (cdr (cdr (car list)))))
      (cdaar (lambda (list) (cdr (car (car list)))))
      (cdadr (lambda (list) (cdr (car (cdr list)))))
      (caaar (lambda (list) (car (car (car list)))))
      (cadar (lambda (list) (cdr (cdr (car list)))))
      (caadr (lambda (list) (cdr (car (cdr list)))))
      (caddr (lambda (list) (cdr (cdr (cdr list))))))
  (current-env))

;; list-n : make an empty list of size n
(letrec 
    ((list-n-iter (lambda (n list)
        (if (= n 0)
            list
            (list-n-iter (- n 1) (cons nil list)))))
    (list-n (lambda (n) (list-n-iter n nil))))
    (current-env))

;; numbered-list-n : make a numbered list from 0 to n of length (n + 1)
(letrec 
    ((numbered-list-iter (lambda (n list) 
        (if (= n 0)
            (cons 0 list)
            (numbered-list-iter (- n 1) (cons n list)))))
    (numbered-list-n (lambda (n)
        (numbered-list-iter n nil))))
    (current-env))


;; nth : get the nth (0-indexed) value of a list 
(letrec ((nth (lambda (place list)
    (if (car list)
        (if (= 0 place)
            (car list)
            (nth (- place 1) (cdr list)))))))
    (current-env))

;; last : get the last element of a list
(let ((last (lambda (list) (car (reverse list))))) (current-env))

;; list-update : update the nth (0-indexed) value of a list 
;;               if (< (length list) n) then list-update returns 
;;               an unchanged list
(letrec 
    ((list-update-iter (lambda (place value old_list new_list)
        (if (car old_list)
            (if (= 0 place)
                (list-update-iter 
                    (- place 1) 
                    nil 
                    (cdr old_list) 
                    (snoc value new_list))
                (list-update-iter
                    (- place 1)
                    value 
                    (cdr old_list)
                    (snoc (car old_list) new_list)))
            new_list)))
    (list-update (lambda (place value list) 
        (list-update-iter place value list nil)))) 
    (current-env))

;; length : determines the (0-indexed) length of a list 
(letrec 
    ((length-iter (lambda (lst cntr)
        (if (neq nil lst)
            (length-iter (cdr lst) (+ 1 cntr))
            cntr)))
    (length (lambda (lst) (length-iter lst 0))))
    (current-env))

;; apply : a preliminary version of apply
(letrec 
    ((apply1 (lambda (f list)
               (if list
		   (if (cdr list)
                       (apply1 (f (car list)) (cdr list))
                       (f (car list)))))))
  (current-env))

;; map : a list map function 
;; TODO : map that can take multiple lists
(letrec ((map (lambda (f list)
                    (if (eq list nil)
                        nil
                        (cons (f (car list))
                              (map f (cdr list)))))))
      (current-env))


;; fold : a fold function over lists 
(letrec 
    ((fold (lambda (op accum lst)
        (if (car lst)
            (fold op (op accum (car lst)) (cdr lst))
            accum))))
    (current-env))

;; concat : concatenates two lists 
(let ((concat (lambda (a b)
		(fold (lambda (l i) (cons i l))
		      b
		      (reverse a)))))
    (current-env))

;; drop : drops n items from the front of list l, returning the rest
(letrec ((drop (lambda (n l)
                 (if (= n 0)
                     l
                     (if l
                         (drop (- n 1) (cdr l)))))))
  (current-env))

;; take : takes the first n items from the front of the list l
(letrec ((take (lambda (n l)
                 (if (= n 0)
                     nil
                     (if l
                         (cons (car l) (take (- n 1) (cdr l))))))))
  (current-env))
