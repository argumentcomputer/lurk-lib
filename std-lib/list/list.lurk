;; !(:load "../bool/bool.lurk")
;; TODO : last, nth, take, drop, filter, reverse

;; a list is of the form (cons a (cons b (cons ... (cons nil)...)))

;; snoc : appends to the right-hand side of a list (opposite of cons)
(letrec 
    ((snoc-iter (lambda (old-list new-list) 
        (if (car old-list)
            (snoc-iter (cdr old-list) (cons (car old-list) new-list))
            new-list)))
    (snoc (lambda (x lst) (snoc-iter (snoc-iter lst '()) (cons x nil))))) 
    (current-env))

;; list-reverse : reverses the order of a list 
(letrec 
    ((reverse-iter (lambda (list1 list2) 
        (if (car list1)
            (reverse-iter (cdr list1) (cons (car list1) list2))
            list2))) 
    (list-reverse (lambda (list) (reverse-iter list nil)))) 
    (current-env))

;; cadr 
(let ((cadr (lambda (list) (car (cdr list))))) (current-env))

;; cddr 
(let ((cddr (lambda (list) (cdr (cdr list))))) (current-env))

;; list-n : make an empty list of size n
(letrec 
    ((list-n-iter (lambda (n list)
        (if (= n 0)
            list
            (list-n-iter (- n 1) (cons nil list)))))
    (list-n (lambda (n) (list-n-iter n nil))))
    (current-env))

;; numbered-list-n : make a numbered list from 0 to n of length (n + 1)
(letrec 
    ((numbered-list-iter (lambda (n list) 
        (if (= n 0)
            (cons 0 list)
            (numbered-list-iter (- n 1) (cons n list)))))
    (numbered-list-n (lambda (n)
        (numbered-list-iter n nil))))
    (current-env))


;; list-get : get the nth (0-indexed) value of a list 
(letrec 
    ((list-get (lambda (place list)
        (if (car list)
            (if (= 0 place)
                (car list)
                (list-get (- place 1) (cdr list)))))))
    (current-env))

;; list-update : update the nth (0-indexed) value of a list 
;;               if (< (length list) n) then list-update returns 
;;               an unchanged list
(letrec 
    ((list-update-iter (lambda (place value old_list new_list)
        (if (car old_list)
            (if (= 0 place)
                (list-update-iter 
                    (- place 1) 
                    nil 
                    (cdr old_list) 
                    (snoc value new_list))
                (list-update-iter
                    (- place 1)
                    value 
                    (cdr old_list)
                    (snoc (car old_list) new_list)))
            new_list)))
    (list-update (lambda (place value list) 
        (list-update-iter place value list nil)))) 
    (current-env))

;; list : make a list out of a (possibly unevaluated) list quote
(letrec ((list (lambda (q)
		 (if (car q)
		     (cons (eval (car q)) (list (cdr q)))
		     '()))))
  (current-env))

;; length : determines the (0-indexed) length of a list 
(letrec 
    ((length-iter (lambda (lst cntr)
        (if (neq nil lst)
            (length-iter (cdr lst) (+ 1 cntr))
            cntr)))
    (length (lambda (lst) (length-iter lst 0))))
    (current-env))

;; apply : a preliminary version of apply
(letrec 
    ((apply (lambda (f list)
        (if (car list)
            (if (eq nil (cdr list))
                (f (car list))
                (apply (f (car list)) (cdr list)))))))
    (current-env))

;; map : a list map function 
;; TODO : map that can take multiple lists
(letrec ((map (lambda (f list)
                    (if (eq list nil)
                        nil
                        (cons (f (car list))
                              (map f (cdr list)))))))
      (current-env))


;; fold : a fold function over lists 
(letrec 
    ((fold (lambda (op accum lst)
        (if (car lst)
            (fold op (op accum (car lst)) (cdr lst))
            accum))))
    (current-env))